- [ООП](#ооп)
  - [История ООП](#история-ооп)
  - [Основные понятия ООП: абстракция, инкапсуляция, наследование, полиморфизм](#основные-понятия-ооп-абстракция-инкапсуляция-наследование-полиморфизм)
  - [Другие понятия ООП](#другие-понятия-ооп)
  - [В чем плюсы и минусы ООП?](#в-чем-плюсы-и-минусы-ооп)

<a name="ооп"></a>

# ООП

<a name="история-ооп"></a>

## История ООП

ООП – парадигма программирования, в которой основными концепциями являются понятия объектов и классов. В центре ООП находится понятие объекта. Объект — это сущность, которой можно посылать сообщения, и которая может на них реагировать, используя свои данные. Объект — это экземпляр класса. Данные объекта скрыты от остальной программы. Сокрытие данных называется инкапсуляцией. Наличие инкапсуляции достаточно для объектности языка программирования, но ещё не означает его объектной ориентированности — для этого требуется наличие наследования. Но даже наличие инкапсуляции и наследования не делает язык программирования в полной мере объектным с точки зрения ООП. Основные преимущества ООП проявляются только в том случае, когда в языке программирования реализован полиморфизм; то есть возможность объектов с одинаковой спецификацией иметь различную реализацию. Первым языком программирования, в котором были предложены принципы объектной ориентированности, была Симула. В момент своего появления (в 1967 году), этот язык программирования предложил поистине революционные идеи: объекты, классы, виртуальные методы и др., однако это всё не было воспринято современниками как нечто грандиозное. Тем не менее, большинство концепций были развиты Аланом Кэйем и Дэном Ингаллсом в языке Smalltalk. Именно он стал первым широко распространённым объектно-ориентированным языком программирования. (C#, C++, Java, Ruby, PHP, Perl, Python). ООП дает возможность создавать расширяемые системы (extensible systems). Это одно из самых значительных достоинств ООП и именно оно отличает данный подход от традиционных методов программирования. Расширяемость (extensibility) означает, что существующую систему можно заставить работать с новыми компонентами, причем без внесения в нее каких-либо изменений. Компоненты могут быть добавлены на этапе выполнения. Smalltalk — объектно-ориентированный язык программирования с динамической типизацией, разработанный в Xerox PARC Аланом Кэйем, Дэном Ингаллсом, Тедом Кэглером, Адель Голдберг, и другими в 1970-х годах. Язык был представлен как Smalltalk-80. Smalltalk оказал большое влияние на развитие многих других языков, таких как: Objective-C, Actor, Java, Groovy и Ruby. Многие идеи 1980-х и 1990-х по написанию программ появились в сообществе Smalltalk. К ним можно отнести рефакторинг, шаблоны проектирования (применительно к ПО), карты «класс — обязанности — взаимодействие» и экстремальное программирование в целом. Си — язык программирования, разработанный в 1969—1973 годах сотрудниками Bell Labs Кеном Томпсоном и Деннисом Ритчи как развитие языка Би. Благодаря близости по скорости выполнения программ, написанных на Си, к языку ассемблера, этот язык получил широкое применение при создании системного программного обеспечения и прикладное программное обеспечение для решения широко круга задач. Язык программирования Си оказал существенное влияние на развитие индустрии программного обеспечения, а его синтаксис стал основой для таких языков программирования как C++, C# и Java.

<a name="основные-понятия-ооп"></a>

## Основные понятия ООП: абстракция, инкапсуляция, наследование, полиморфизм

__Абстракция__ – это придание объекту характеристик, которые чётко определяют его концептуальные границы, отличая от всех других объектов. Основная идея состоит в том, чтобы отделить способ использования составных объектов данных от деталей их реализации в виде более простых объектов, подобно тому, как функциональная абстракция разделяет способ использования функции и деталей её реализации в терминах более примитивных функций, таким образом, данные обрабатываются функцией высокого уровня с помощью вызова функций низкого уровня. (Пример: говорить о предметах, не упоминая материалы, из которых они сделаны). Абстракция позволяет задействовать концепцию, игнорируя ее некоторые детали и работая с разными деталями на разных уровнях. Имея дело с составным объектом, вы имеете дело с абстракцией. Если вы рассматриваете объект как «дом», а не как комбинацию стекла, древесины и гвоздей, вы прибегаете к абстракции. Если вы рассматриваете множество домов как «город», вы прибегаете к другой абстракции. Базовые классы представляют собой абстракции, позволяющие концентрироваться на общих атрибутах производных классов и игнорировать детали конкретных классов при работе с базовым классом. Удачный интерфейс класса — это абстракция, позволяющая сосредоточиться на интерфейсе, не беспокоясь о внутренних механизмах работы класса. Мы используем абстракции на каждом шагу. Если б, открывая или закрывая дверь, вы должны были иметь дело с отдельными волокнами древесины, молекулами лака и стали, вы вряд ли смогли бы войти в дом или выйти из него. Абстракция — один из главных способов борьбы со сложностью реального мира.
Слой абстрагирования (или уровень абстракции) — это способ уйти от деталей реализации конкретного множества функций.

<img src="https://github.com/sashakid/ios-guide/blob/master/Images/abstraction.png">

__Инкапсуляция__ – скрытие методов и переменных от других методов или переменных или других частей программы. Сокрытие реализации целесообразно применять в следующих целях:

- При необходимости максимальной локализации предстоящих изменений, когда изменяется только работа объекта, а не программы;
- При необходимости предсказания предстоящих изменений и их последствий;
- При необходимости очистки глобальной области видимости.

Когда абстракция нас покидает, на помощь приходит инкапсуляция. Абстракция говорит: «Вы можете рассмотреть объект с общей точки зрения». Инкапсуляция добавляет: «Более того, вы не можете рассмотреть объект с иной точки зрения».
Продолжим нашу аналогию: инкапсуляция позволяет вам смотреть на дом, но не дает подойти достаточно близко, чтобы узнать, из чего сделана дверь. Инкапсуляция позволяет вам знать о существовании двери, о том, открыта она или заперта, но при этом вы не можете узнать, из чего она сделана (из дерева, стекловолокна, стали или другого материала), и уж никак не сможете рассмотреть отдельные волокна древесины.

__Наследование__

Процесс, посредством которого один объект может приобретать свойства другого. Точнее, объект может наследовать основные свойства другого объекта и добавлять к ним черты, характерные только для него. Польза наследования в том, что оно дополняет идею абстракции. Абстракция позволяет представить объекты с разным уровнем детальности. Если помните, на одном уровне мы рассматривали дверь как набор определенных типов молекул, на втором — как набор волокон древесины, а на третьем — как что-то, что защищает нас от воров. Древесина имеет определенные свойства — скажем, вы можете распилить ее пилой или склеить столярным клеем, — при этом и плинтусы, и подоконники имеют общие свойства древесины, но вместе с тем и некоторые специфические свойства. Наследование упрощает программирование, позволяя создать универсальные методы для выполнения всего, что основано на общих свойствах дверей, и затем написать специфические методы для выполнения специфических операций над конкретными типами дверей. Некоторые операции, такие как `Open()` или `Close()`, будут универсальными для всех дверей: внутренних, входных, стеклянных, стальных — каких угодно. Поддержка языком операций вроде `Open()` или `Close()` при отсутствии информации о конкретном типе двери вплоть до периода выполнения называется полиморфизмом. Объектно-ориентированные языки, такие как C++, Java и более поздние версии Microsoft Visual Basic, поддерживают и наследование, и полиморфизм.

__Агрегирование__

Методика создания нового класса из уже существующих классов путём включения, называемого также делегированием. Об агрегировании также часто говорят как об «отношении принадлежности» по принципу «у машины есть корпус, колёса и двигатель». Вложенные объекты нового класса обычно объявляются закрытыми, что делает их недоступными для прикладных программистов, работающих с классом. С другой стороны, создатель класса может изменять эти объекты, не нарушая при этом работы существующего клиентского кода. Кроме того, замена вложенных объектов на стадии выполнения программы позволяет динамически изменять её поведение. Механизм наследования такой гибкостью не обладает, поскольку для производных классов устанавливаются ограничения, проверяемые на стадии компиляции. На базе агрегирования реализуется методика делегирования, когда поставленная перед внешним объектом задача перепоручается внутреннему объекту, специализирующемуся на решении задач такого рода.

Агрегация (агрегирование по ссылке) — отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.

Композиция (агрегирование по значению) — более строгий вариант агрегирования, когда включаемый объект может существовать только как часть контейнера. Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.

```objectivec
@interface Unicycle : NSObject {
  Pedal *pedal;
  Tire *tire;
}
@end
```

<img src="https://github.com/sashakid/ios-guide/blob/master/Images/abstract_classes.png">
(Абстрактный класс белым цветом)

_Как имитировать множественное наследование?_

Композиция:

```objectivec
@interface ClassA : NSObject {
}
- (void)methodA;
@end

@interface ClassB : NSObject {
}

- (void)methodB;
@end

@interface MyClass : NSObject {
  ClassA *a;
  ClassB *b;
}
- (id)initWithA:(ClassA *)anA b:(ClassB *)aB;
- (void)methodA;
- (void)methodB;
@end
```

__Полиморфизм__ – возможность объектов с одинаковой спецификацией иметь различную реализацию (использование одного имени для решения двух или более схожих, но технически разных задач). Если функция описывает разные реализации (возможно, с различным поведением) для ограниченного набора явно заданных типов и их комбинаций, это называется ситуативным полиморфизмом (ad hoc polymorphism). Ситуативный полиморфизм поддерживается во многих языках посредством перегрузки функций и методов.
Если же код написан отвлеченно от конкретного типа данных и потому может свободно использоваться с любыми новыми типами, имеет место параметрический полиморфизм. Некоторые языки совмещают различные формы полиморфизма, порой сложным образом, что формирует самобытную идеологию в них и влияет на применяемые методологии декомпозиции задач. Например, в Smalltalk любой класс способен принять сообщения любого типа, и либо обработать его самостоятельно (в том числе посредством интроспекции), либо ретранслировать другому классу — таким образом, несмотря на широкое использование перегрузки функций, формально любая операция является неограниченно полиморфной и может применяться к данным любого типа.

<a name="другие-понятия-ооп"></a>

## Другие понятия ООП

__Конструктор__

В объектно-ориентированном программировании конструктор класса (от англ. constructor, иногда сокращают ctor) — специальный блок инструкций, вызываемый при создании объекта.
Конструктор схож с методом, но отличается от метода тем, что не имеет явным образом определённого типа возвращаемых данных, не наследуется, и обычно имеет различные правила для рассматриваемых модификаторов. Конструкторы часто выделяются наличием одинакового имени с именем класса, в котором объявляется. Их задача — инициализировать члены объекта и определить инвариант класса, сообщив в случае некорректности инварианта. Корректно написанный конструктор оставит объект в «правильном» состоянии. Неизменяемые объекты тоже должны быть проинициализированы конструктором.
В большинстве языков конструктор может быть перегружен, что позволяет использовать несколько конструкторов в одном классе, причём каждый конструктор может иметь различные параметры.

__Деструктор__

Вызывается при уничтожении объекта. Он обычно используется для освобождения памяти.

__Виртуальный метод__

В объектно-ориентированном программировании метод (функция) класса, который может быть переопределён в классах-наследниках так, что конкретная реализация метода для вызова будет определяться во время исполнения. Таким образом, программисту не обязательно знать точный тип объекта для работы с ним через виртуальные методы: достаточно лишь знать, что объект принадлежит классу или наследнику класса, в котором метод объявлен. Виртуальные методы — один из важнейших приёмов реализации полиморфизма. Они позволяют создавать общий код, который может работать как с объектами базового класса, так и с объектами любого его класса-наследника. При этом базовый класс определяет способ работы с объектами и любые его наследники могут предоставлять конкретную реализацию этого способа. В некоторых языках программирования, например в Java, нет понятия виртуального метода, данное понятие следует применять лишь для языков, в которых методы родительского класса не могут быть переопределены по умолчанию, а только с помощью некоторых вспомогательных ключевых слов. В некоторых же (как, например, в Python), все методы — виртуальные.
Базовый класс может и не предоставлять реализации виртуального метода, а только декларировать его существование. Такие методы без реализации называются «чистыми виртуальными» (перевод англ.  pure virtual) или абстрактными. Класс, содержащий хотя бы один такой метод, тоже будет абстрактным. Объект такого класса создать нельзя (в некоторых языках допускается, но вызов абстрактного метода приведёт к ошибке). Наследники абстрактного класса должны предоставить реализацию для всех его абстрактных методов, иначе они, в свою очередь, будут абстрактными классами.
Для каждого класса, имеющего хотя бы один виртуальный метод, создаётся таблица виртуальных методов. Каждый объект хранит указатель на таблицу своего класса. Для вызова виртуального метода используется такой механизм: из объекта берётся указатель на соответствующую таблицу виртуальных методов, а из неё, по фиксированному смещению, — указатель на реализацию метода, используемого для данного класса. При использовании множественного наследования ситуация несколько усложняется за счёт того, что таблица виртуальных методов становится нелинейной.
__Принцип единственной обязанности__ (Single responsibility principle) обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.

<a name="в-чем-плюсы-и-минусы-ооп"></a>

## В чем плюсы и минусы ООП?

__Общие положения__

Объектно-ориентированное программирование (ООП) — парадигма, основанная на представлении программы в виде совокупности объектов, взаимодействующих между собой. Каждый объект — это экземпляр определённого класса, обладающий состоянием (данными) и поведением (методами).

Преимущества

•	Конструирование из компонентов. Классы позволяют создавать приложения из переиспользуемых компонентов с чётко определённой функциональностью, скрывая реализацию за абстракциями.

•	Модульность и читаемость. Программы легче поддерживать и масштабировать, поскольку логика разделена между классами, каждый из которых отвечает за свою часть.

•	Переиспользуемость кода. Благодаря наследованию и полиморфизму, повторное использование кода становится проще.

•	Соответствие мышлению. ООП приближает модель программы к реальному миру, где объекты взаимодействуют друг с другом.

Недостатки

•	Разрастание иерархий. ООП может привести к слишком сложным иерархиям классов, где логика “размыта” между базовыми и производными классами. Это усложняет понимание и отладку.

•	Избыточность. В некоторых случаях реализация становится излишне формализованной и перегруженной абстракциями, где простое решение было бы эффективнее.

•	Скрытая логика. Сложность в отслеживании того, где именно реализовано поведение объекта, особенно при переопределении методов в наследниках.

___

__Полиморфизм__

Преимущества

•	Единый интерфейс — множество реализаций. Можно использовать один и тот же интерфейс для объектов разных типов, что упрощает архитектуру и делает код более гибким.

•	Унификация доступа. Позволяет обрабатывать объекты разного типа одинаковым образом.

```
for (id object in array) {
    NSLog(@"%@", object);
}
```

•	Расширяемость. Новые типы можно добавлять без изменения существующего кода

•	Обобщение алгоритмов. Можно писать универсальные алгоритмы, применимые к широкому классу объектов.

•	Создание фреймворков и полуфабрикатов. Библиотеки можно проектировать в виде расширяемых модулей, которые дорабатываются под конкретное приложение.

Недостатки

•	Производительность. Использование позднего связывания (dynamic dispatch) может замедлить выполнение программы.

•	Порог вхождения. Для эффективного использования требуется знание больших библиотек классов, что сравнимо по сложности с изучением нового языка.

•	Ресурсоёмкость. В языках, где даже примитивы — это объекты, возникают издержки по памяти и скорости.

•	Изменчивость поведения. Возможность подмены объекта во время выполнения может неожиданно изменить поведение программы.

___

__Инкапсуляция__

Преимущества

•	Сокрытие реализации. Инкапсуляция позволяет скрывать внутреннее устройство объекта и защищать данные от несанкционированного доступа.

•	Безопасность и надёжность. Код становится устойчивее, поскольку изменения в одном месте не затрагивают остальной код.

•	Упрощение интерфейсов. Пользователю класса не нужно знать, как всё работает внутри — достаточно публичных методов.

Недостатки

•	Черный ящик. Функции становятся непрозрачными. Если неизвестна реализация, сложно предсказать поведение при определённых входных данных.

•	Сложность обучения. Без возможности “пощупать” классы и посмотреть, как они устроены, трудно понять принципы работы. Требуется опыт и итеративный подход к проектированию.

•	Скрытие состояния. Хотя идея сокрытия состояния полезна, иногда состояние важно (например, баланс банковского счёта). Полное его сокрытие может мешать пониманию и контролю.

___

__Наследование__

Преимущества

•	Повторное использование кода. Можно переиспользовать поведение базового класса, переопределяя только нужные части.

•	Лаконичность. Не нужно повторять реализацию, если она уже есть в родительском классе.

•	Организация абстракций. Позволяет выразить отношение «является» (is-a) между объектами.

Недостатки

•	Ограниченность. Класс, унаследованный от одного предка, не может напрямую наследовать другой (в языках без множественного наследования).

•	Хрупкость. Изменение базового класса может привести к ошибкам в наследниках.

•	Проблема «вверх-вниз». Чтобы понять поведение класса-наследника, нужно постоянно обращаться к родительским классам. Это затрудняет чтение и понимание кода.

•	Размывание инкапсуляции. Наследование раскрывает внутреннюю реализацию базового класса, нарушая принцип инкапсуляции. Наследник получает не только интерфейс, но и реализацию, что делает его зависимым от деталей, которые могли бы быть скрыты.

